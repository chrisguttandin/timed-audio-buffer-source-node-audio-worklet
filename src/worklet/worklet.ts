// This is the minified and stringified code of the timed-audio-buffer-source-node-audio-worklet-processor package.
export const worklet = `(()=>{"use strict";class e extends AudioWorkletProcessor{constructor(e){let{numberOfInputs:t,numberOfOutputs:r,outputChannelCount:o,processorOptions:n}=e;var s;const u="object"==typeof n&&null!==n&&"buffer"in n?n.buffer:null;if(!(null===u||Array.isArray(u)&&u.every((e=>e instanceof Float32Array))))throw new Error("The buffer needs to be either null or an array with where each element is a Float32Array.");if(0!==t)throw new Error("The numberOfInputs must be 0.");if(1!==r)throw new Error("The numberOfOutputs must be 1.");const i=null!==(s=null==u?void 0:u.length)&&void 0!==s?s:1;if(void 0===o||1!==o.length||i!==o[0])throw new Error("The outputChannelCount must match the number of channels of the buffer.");const f="object"==typeof n&&null!==n&&"position"in n?n.position:0;if("number"!=typeof f)throw new Error('The position needs to be of type "number".');const l="object"==typeof n&&null!==n&&"timestamp"in n?n.timestamp:0;if("number"!=typeof l)throw new Error('The timestamp needs to be of type "number".');super(),this._buffer=u,this._position=f,this._timestamp=l}process(e,t){let[r]=t;if(null!==this._buffer){const e=this._buffer.length;for(let t=0;t<e;t+=1){const e=this._buffer[t],o=r[t];for(let t=0;t<128;t+=1){const r=this._position+currentFrame-this._timestamp+t;r>=0&&r<e.length&&(o[t]=e[r])}}}return!0}}e.parameterDescriptors=[],registerProcessor("timed-audio-buffer-source-node-audio-worklet-processor",e)})();`; // tslint:disable-line:max-line-length
