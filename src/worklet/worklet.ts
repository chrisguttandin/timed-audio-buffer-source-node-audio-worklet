// This is the minified and stringified code of the timed-audio-buffer-source-node-audio-worklet-processor package.
export const worklet = `(()=>{"use strict";class e extends AudioWorkletProcessor{constructor(e){let{numberOfInputs:t,numberOfOutputs:r,outputChannelCount:o,processorOptions:n}=e;var s;const i="object"==typeof n&&null!==n&&"buffer"in n?n.buffer:null;if(!(null===i||Array.isArray(i)&&i.every((e=>e instanceof Float32Array))))throw new Error("The buffer needs to be either null or an array with where each element is a Float32Array.");if(1!==t)throw new Error("The numberOfInputs must be 1.");if(1!==r)throw new Error("The numberOfOutputs must be 1.");const u=null!==(s=null==i?void 0:i.length)&&void 0!==s?s:1;if(void 0===o||1!==o.length||u!==o[0])throw new Error("The outputChannelCount must match the number of channels of the buffer.");const f="object"==typeof n&&null!==n&&"position"in n?n.position:0;if("number"!=typeof f)throw new Error('The position needs to be of type "number".');const h="object"==typeof n&&null!==n&&"timestamp"in n?n.timestamp:0;if("number"!=typeof h)throw new Error('The timestamp needs to be of type "number".');super(),this._buffer=i,this._position=f,this._timestamp=h}process(e,t){let[r]=e,[o]=t;if(r.length>0){const[e]=r;e.length>1&&(this._position=Math.round(e[0]),this._timestamp=Math.round(e[1]))}if(null!==this._buffer){const e=this._buffer.length;for(let t=0;t<e;t+=1){const e=this._buffer[t],r=o[t];for(let t=0;t<128;t+=1){const o=this._position+currentFrame-this._timestamp+t;o>=0&&o<e.length&&(r[t]=e[o])}}}return!0}}e.parameterDescriptors=[],registerProcessor("timed-audio-buffer-source-node-audio-worklet-processor",e)})();`; // tslint:disable-line:max-line-length
