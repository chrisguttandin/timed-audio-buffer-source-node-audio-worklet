// This is the minified and stringified code of the timed-audio-buffer-source-node-audio-worklet-processor package.
export const worklet = `(()=>{"use strict";class e extends AudioWorkletProcessor{constructor(e){let{numberOfInputs:t,numberOfOutputs:o,outputChannelCount:r,processorOptions:n}=e;var s;const i="object"==typeof n&&null!==n&&"buffer"in n?n.buffer:null;if(!(null===i||Array.isArray(i)&&i.every((e=>e instanceof Float32Array))))throw new Error("The buffer needs to be either null or an array with where each element is a Float32Array.");if(1!==t)throw new Error("The numberOfInputs must be 1.");if(1!==o)throw new Error("The numberOfOutputs must be 1.");const u=null!==(s=null==i?void 0:i.length)&&void 0!==s?s:1;if(void 0===r||1!==r.length||u!==r[0])throw new Error("The outputChannelCount must match the number of channels of the buffer.");const l="object"==typeof n&&null!==n&&"position"in n?n.position:0;if("number"!=typeof l)throw new Error('The position needs to be of type "number".');const h="object"==typeof n&&null!==n&&"timestamp"in n?n.timestamp:0;if("number"!=typeof h)throw new Error('The timestamp needs to be of type "number".');const f="object"==typeof n&&null!==n&&"velocity"in n?n.velocity:0;if(![0,1].includes(f))throw new Error("The velocity needs to be either 0 or 1.");super(),this._buffer=i,this._position=l,this._timestamp=h,this._velocity=f}process(e,t){let[o]=e,[r]=t;if((null==o?void 0:o.length)>0){const[e]=o;e.length>1&&(this._position=Math.round(e[0]),this._timestamp=Math.round(e[1]),this._velocity=Math.round(e[2]))}if(null!==this._buffer){const e=this._buffer.length;for(let t=0;t<e;t+=1){const e=this._buffer[t],o=r[t];for(let t=0;t<128;t+=1){const r=this._position+(currentFrame-this._timestamp+t)*this._velocity;r>=0&&r<e.length&&(o[t]=e[r])}}}return!0}}e.parameterDescriptors=[],registerProcessor("timed-audio-buffer-source-node-audio-worklet-processor",e)})();`; // tslint:disable-line:max-line-length
